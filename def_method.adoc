== 定义一个方法

  - 方法名应以小写字母开头。如果您以大写字母作为方法名的开头，Ruby 可能会把它当作常量，从而导致不正确地解析调用

  -  表示查询的方法名通常以'?'结尾,例如 instance_of?.

   "危险的"或者会修改接受者对像的方法,可以用'!'结尾. 例如,String 提供了chop和chop!方法. 第一个方法返回一个修改后的字符串;第二个则就地修改对象.

   可以被赋值的方法以一个等号(=)结尾

  - 通过指定接收者,方法的名称,可选的参数及block,来调用一个方法

  - ==	检查两个操作数的值是否相等，如果相等则条件为真。	(a == b) 不为真。

    !=	检查两个操作数的值是否相等，如果不相等则条件为真。	(a != b) 为真。

    <	检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(a < b) 为真。

    >=	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(a >= b) 不为真。

    <=	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(a <= b) 为真。

    <=>	联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1。	(a <=> b) 返回 -1。

    ===	用于测试 case 语句的 when 子句内的相等。	(1...10) === 5 返回 true。

    .eql?	如果接收器和参数具有相同的类型和相等的值，则返回 true。	1 == 1.0 返回 true，但是 1.eql?(1.0) 返回 false。

    equal?	如果接收器和参数具有相同的对象 id，则返回 true。	如果 aObj 是 bObj 的副本，那么 aObj == bObj 返回 true，a.equal?bObj 返回 false，但是 a.equal?aObj 返回 true。

    =	简单的赋值运算符，把右操作数的值赋给左操作数	c = a + b 将把 a + b 的值赋给 c

    +=	加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数	c += a 相当于 c = c + a

    -=	减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数	c -= a 相当于 c = c - a

    *=	乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数	c *= a 相当于 c = c * a

    /=	除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数	c /= a 相当于 c = c / a

    %=	求模且赋值运算符，求两个操作数的模赋值给左操作数	c %= a 相当于 c = c % a

    **=	指数且赋值运算符，执行指数计算，并赋值给左操作数	c **= a 相当于 c = c ** a

   - 循环控制结构 break,redo 和next可以让你改变循环或者迭代的正常流程.

    break终止最接近的封闭循环体,然后继续执行block后面的语句.

    redo从循环头重新执行循环,但不重计算循环条件表达式或者获得迭代中的下一个元素.

    next跳到本次循环的末尾,并开始下一次迭代.

    - retry语句 是从头重新执行一个循环,在重新执行之前会计算传递给迭代的所有参数.
